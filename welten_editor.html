<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Weltensymbol Editor</title>
  <style>
    body {
      background: #121212;
      color: white;
      font-family: monospace;
      padding: 20px;
      text-align: center;
    }
    #editorContainer {
      max-width: 800px;
      margin: auto;
    }
    /* Button-Leiste für die Weltauswahl statt Dropdown */
    #worldButtons {
      margin-bottom: 15px;
    }
    #worldButtons button {
      margin: 3px;
      padding: 5px 10px;
      font-size: 1em;
      cursor: pointer;
      background-color: #333;
      border: none;
      color: white;
      transition: background 0.2s;
    }
    #worldButtons button:hover {
      background-color: #555;
    }
    /* Extra Info-Zeile für Spieler- und Ziel-Symbole */
    #playerTargetInfo {
      margin-bottom: 15px;
      font-size: 1.2em;
    }
    #playerTargetInfo span {
      margin: 0 10px;
      font-size: 1.8em;
      font-weight: bold;
    }
    /* Symbol-Palette */
    #symbolPalette {
      margin-top: 10px;
    }
    .symbol {
      display: inline-block;
      padding: 5px;
      border: 1px solid white;
      margin: 2px;
      cursor: pointer;
      font-size: 1.5em;
      transition: background 0.2s, border-color 0.2s;
    }
    .symbol.selected {
      background: white;
      color: black;
    }
    /* Markierungen für Spieler- und Ziel-Symbole */
    .playerSymbol {
      border-color: limegreen;
    }
    .targetSymbol {
      border-color: red;
    }
    h2 {
      margin-top: 30px;
    }
    /* Raster-Ausgabe: 30 Spalten à 2ch, 10 Zeilen */
    #output {
      display: grid;
      grid-template-columns: repeat(30, 2ch);
      gap: 1px;
      width: 60ch;
      height: 10em;
      background: black;
      padding: 10px;
      border: 1px solid white;
      margin: 10px auto;
      overflow: hidden;
      font-size: 2em;
      line-height: 1.2em;
    }
    /* Textfeld mit exakt denselben Maßen */
    #gridOutput {
      width: 60ch;
      height: 10em;
      background: black;
      color: white;
      padding: 10px;
      border: 1px solid white;
      margin-top: 10px;
      font-family: monospace;
      font-size: 2em;
      line-height: 1.2em;
      overflow: hidden;
      resize: none;
    }
    .cell {
      width: 2ch;
      height: 2ch;
      text-align: center;
      line-height: 2ch;
      border: 1px solid white;
      cursor: pointer;
      transition: background 0.2s;
    }
    .cell:hover {
      background: #333;
    }
    button {
      margin: 10px 5px;
      padding: 5px 10px;
      cursor: pointer;
    }
  </style>
  <!-- Lade worldData.js extern (enthält alle Welt-Daten inkl. description, player und target) -->
  <script src="worldData.js"></script>
  <!-- html2canvas (für Kopierfunktionen) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
  <div id="editorContainer">
    <h1>Weltensymbol Editor</h1>
    
    <!-- Welt-Buttons als Auswahl -->
    <div id="worldButtons"></div>
    
    <!-- Extra Zeile: Anzeige der Spieler- und Zielfiguren -->
    <div id="playerTargetInfo"></div>
    
    <!-- Symbol-Palette -->
    <div id="symbolPalette"></div>
    
    <h2>Ausgabefeld</h2>
    <!-- Visuelles Raster -->
    <div id="output"></div>
    <!-- Textfeld, das das Raster exakt darstellt -->
    <textarea id="gridOutput" readonly></textarea>
    <br>
    <button id="clearGrid">Grid leeren</button>
    <button id="copyGrid">Grid kopieren (Text)</button>
    <button id="copyBitmap">Bitmap kopieren</button>
    <button id="generateAltText">ALT Text generieren</button>
    <button id="transferToGame">In Spiel übernehmen</button>
  </div>
  
  <script>
    // Raster-Größe: 30 Spalten, 10 Zeilen
    const gridCols = 30;
    const gridRows = 10;
    let gridData = [];
    let selectedSymbol = "";
    let lastWorldType = "galaxy"; // Standardwelt
    
    // Füllt die Welt-Buttons basierend auf worldData
    function populateWorldButtons() {
      const container = document.getElementById("worldButtons");
      container.innerHTML = "";
      for (let world in worldData) {
        const btn = document.createElement("button");
        btn.innerText = world;
        btn.addEventListener("click", () => {
          lastWorldType = world;
          highlightWorldButton(world);
          updatePlayerTargetInfo();
          populateSymbolPalette();
        });
        container.appendChild(btn);
      }
    }
    
    // Hebt den aktuell ausgewählten Welt-Button hervor
    function highlightWorldButton(selectedWorld) {
      const buttons = document.querySelectorAll("#worldButtons button");
      buttons.forEach(btn => {
        btn.style.backgroundColor = (btn.innerText === selectedWorld) ? "#555" : "#333";
      });
    }
    
    // Aktualisiert die Info-Zeile mit Spieler- und Ziel-Symbol
    function updatePlayerTargetInfo() {
      const infoDiv = document.getElementById("playerTargetInfo");
      const currentWorld = worldData[lastWorldType];
      infoDiv.innerHTML =
        "Spielersymbol: <span style='color: limegreen;'>" + currentWorld.player + "</span> " +
        " | Zielsymbol: <span style='color: red;'>" + currentWorld.target + "</span>";
    }
    
    // Füllt die Symbol-Palette basierend auf der aktuell ausgewählten Welt aus worldData
    function populateSymbolPalette() {
      const palette = document.getElementById("symbolPalette");
      palette.innerHTML = "";
      const currentWorld = worldData[lastWorldType];
      const symbols = currentWorld.symbols.concat(currentWorld.rare, currentWorld.bottom);
      symbols.forEach(sym => {
        const span = document.createElement("span");
        span.classList.add("symbol");
        span.textContent = sym;
        if (sym === currentWorld.player) {
          span.classList.add("playerSymbol");
        }
        if (sym === currentWorld.target) {
          span.classList.add("targetSymbol");
        }
        span.addEventListener("click", () => {
          document.querySelectorAll(".symbol").forEach(el => el.classList.remove("selected"));
          span.classList.add("selected");
          selectedSymbol = sym;
        });
        palette.appendChild(span);
      });
    }
    
    // Initialisiert das Raster (grid)
    function initGrid() {
      gridData = [];
      const output = document.getElementById("output");
      output.innerHTML = "";
      for (let r = 0; r < gridRows; r++) {
        let row = [];
        for (let c = 0; c < gridCols; c++) {
          row.push(" ");
          const cell = document.createElement("div");
          cell.classList.add("cell");
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.textContent = " ";
          cell.addEventListener("click", () => {
            if (selectedSymbol !== "") {
              cell.textContent = selectedSymbol;
              gridData[r][c] = selectedSymbol;
              updateGridOutput();
            }
          });
          output.appendChild(cell);
        }
        gridData.push(row);
      }
      updateGridOutput();
    }
    
    // Aktualisiert das Textfeld, das den Rasterinhalt als Text darstellt
    function updateGridOutput() {
      const textArea = document.getElementById("gridOutput");
      textArea.value = gridData.map(row => row.join("")).join("\n");
    }
    
    function clearGrid() {
      gridData = gridData.map(row => row.map(() => " "));
      document.querySelectorAll("#output .cell").forEach(cell => cell.textContent = " ");
      updateGridOutput();
    }
    
    function copyGridToClipboard() {
      navigator.clipboard.writeText(document.getElementById("gridOutput").value)
        .then(() => alert("Grid kopiert!"))
        .catch(err => alert("Fehler beim Kopieren: " + err));
    }
    
    function copyGridAsBitmap() {
      html2canvas(document.getElementById("gridOutput")).then(canvas => {
        canvas.toBlob(blob => {
          const item = new ClipboardItem({ "image/png": blob });
          navigator.clipboard.write([item]).then(() => {
            alert("Bitmap kopiert!");
          }).catch(err => {
            console.error("Fehler beim Kopieren: ", err);
            alert("Fehler beim Kopieren der Bitmap.");
          });
        });
      });
    }
    
    function transferToGame() {
      const params = new URLSearchParams();
      params.set("world", encodeURIComponent(lastWorldType));
      const gridText = gridData.map(row => row.join("")).join("\n");
      params.set("grid", encodeURIComponent(gridText));
      window.location.href = "Weltengenerator_Mit_Spiel.html?" + params.toString();
    }
    
    window.addEventListener("load", () => {
      lastWorldType = "galaxy"; // Standardwelt
      populateWorldButtons();
      highlightWorldButton(lastWorldType);
      updatePlayerTargetInfo();
      populateSymbolPalette();
      initGrid();
    });
    
    document.getElementById("clearGrid").addEventListener("click", clearGrid);
    document.getElementById("copyGrid").addEventListener("click", copyGridToClipboard);
    document.getElementById("copyBitmap").addEventListener("click", copyGridAsBitmap);
    document.getElementById("generateAltText").addEventListener("click", () => {
      const currentWorld = worldData[lastWorldType];
      const altText = "Alternativtext: Dieses Bild zeigt eine " + (currentWorld.description || lastWorldType) +
        " Welt, erstellt mit dem Weltensymbol Editor. Das Raster hat " + gridRows + " Zeilen und " + gridCols + " Spalten.";
      navigator.clipboard.writeText(altText)
        .then(() => alert("ALT Text kopiert!"))
        .catch(err => alert("Fehler beim Kopieren des ALT Texts: " + err));
    });
    document.getElementById("transferToGame").addEventListener("click", transferToGame);
  </script>
</body>
</html>

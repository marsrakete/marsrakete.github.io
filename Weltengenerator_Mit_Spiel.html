<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <!-- Deaktiviert das Zoomen auf mobilen Geräten -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Weltengenerator mit Spiel</title>
  <style>
    body {
      background-color: #121212;
      color: white;
      font-family: monospace;
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    /* Gleiche Maße für visuelle und textuelle Ausgabe */
    #output, #gridOutput {
      width: 60ch;
      height: 15em;
      background: black;
      color: white;
      padding: 10px;
      border: 1px solid white;
      display: inline-block;
      overflow: hidden;
      line-height: 1.2em;
      font-size: 2em;
      margin-top: 10px;
    }
    .cell {
      display: inline-block;
      width: 2ch;
      text-align: center;
    }
    #gameInfo {
      font-size: 1.2em;
      margin-bottom: 10px;
    }
    #statusLine {
      font-size: 1.2em;
      margin-top: 10px;
    }
    button {
      margin: 5px;
      padding: 10px;
      background: #333;
      color: white;
      border: none;
      cursor: pointer;
    }
    button:hover {
      background: #555;
    }
    /* Virtuelle Bewegungstasten */
    #virtualButtons {
      margin-top: 20px;
    }
  </style>
  <!-- Lade worldData.js extern -->
  <script src="worldData.js"></script>
  <!-- html2canvas -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
  <h1>Weltengenerator mit Spiel</h1>
  
  <div id="gameInfo"></div>
  <div id="statusLine">
    <span id="timerDisplay">Zeit: 0 s</span> | <span id="foundCount">Gefundene Ziele: 0</span>
  </div>
  
  <div id="output"></div>
  <textarea id="gridOutput" readonly></textarea>
  
  <div id="virtualButtons">
    <button onclick="movePlayer(0,-1)">↑</button><br>
    <button onclick="movePlayer(-1,0)">←</button>
    <button onclick="movePlayer(1,0)">→</button><br>
    <button onclick="movePlayer(0,1)">↓</button>
  </div>
  
  <br>
  <button onclick="copyToClipboard()">Kopieren</button>
  <button onclick="generateAltText()">ALT Text generieren</button>
  <button onclick="transferToEditor()">Zurück zum Editor</button>
  
  <script>
    let lastWorldType = 'galaxy';
    const width = 30;
    const height = 10;
    let gameGrid = [];
    let playerX = 0, playerY = 0;
    let foundCount = 0;
    let initialTargetCount = 0;
    let timerStart = null;
    let timerInterval = null;
    
    // Greife auf worldData zu
    function playPewSound() {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = ctx.createOscillator();
      const gain = ctx.createGain();
      oscillator.type = "square";
      oscillator.frequency.setValueAtTime(440, ctx.currentTime);
      oscillator.connect(gain);
      gain.connect(ctx.destination);
      oscillator.start();
      gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.2);
      oscillator.stop(ctx.currentTime + 0.2);
    }
    
    function playPowSound() {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = ctx.createOscillator();
      const gain = ctx.createGain();
      oscillator.type = "sawtooth";
      oscillator.frequency.setValueAtTime(200, ctx.currentTime);
      oscillator.connect(gain);
      gain.connect(ctx.destination);
      oscillator.start();
      gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.2);
      oscillator.stop(ctx.currentTime + 0.2);
    }
    
    function playTuschSound() {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      if (ctx.state === 'suspended') { ctx.resume(); }
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "sine";
      let t = ctx.currentTime;
      osc.frequency.setValueAtTime(400, t);
      osc.frequency.linearRampToValueAtTime(400, t + 0.1);
      osc.frequency.linearRampToValueAtTime(300, t + 0.2);
      osc.frequency.linearRampToValueAtTime(400, t + 0.3);
      osc.frequency.linearRampToValueAtTime(150, t + 1.2);
      gain.gain.setValueAtTime(0.7, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 1.2);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(t);
      osc.stop(t + 1.2);
    }
    
    function updateTimer() {
      const seconds = Math.floor((Date.now() - timerStart) / 1000);
      document.getElementById("timerDisplay").innerText = "Zeit: " + seconds + " s";
    }
    
    function renderGameGrid() {
      let outputHTML = "";
      for (let i = 0; i < height; i++) {
        let rowStr = "";
        for (let j = 0; j < width; j++) {
          rowStr += `<span class="cell">${gameGrid[i][j]}</span>`;
        }
        outputHTML += rowStr + "<br>";
      }
      document.getElementById("output").innerHTML = outputHTML;
      document.getElementById("gridOutput").value = gameGrid.map(row => row.join("")).join("\n");
    }
    
    function loadGameFromParams() {
      const params = new URLSearchParams(window.location.search);
      if (params.has("world") && params.has("grid")) {
        const world = params.get("world");
        const gridText = params.get("grid");
        lastWorldType = world;
        const rows = gridText.split("\n");
        gameGrid = rows.map(row => {
          let arr = Array.from(row);
          if (arr.length < width) {
            arr = arr.concat(Array(width - arr.length).fill(" "));
          } else if (arr.length > width) {
            arr = arr.slice(0, width);
          }
          return arr;
        });
        const currentWorld = worldData[lastWorldType];
        const currentGame = { player: currentWorld.player, target: currentWorld.target };
        initialTargetCount = gameGrid.flat().filter(cell => cell === currentGame.target).length;
        let foundPlayer = false;
        for (let i = 0; i < gameGrid.length && !foundPlayer; i++) {
          for (let j = 0; j < gameGrid[i].length; j++) {
            if (gameGrid[i][j] === currentGame.player) {
              playerX = j;
              playerY = i;
              foundPlayer = true;
              break;
            }
          }
        }
        if (!foundPlayer) {
          alert("Fehler: Das Spielersymbol (" + currentGame.player + ") wurde im Grid nicht gefunden.");
        }
        renderGameGrid();
      } else {
        generateDefaultGrid();
      }
    }
    
    function generateDefaultGrid() {
      gameGrid = [];
      for (let i = 0; i < height; i++) {
        let row = [];
        for (let j = 0; j < width; j++) {
          row.push(" ");
        }
        gameGrid.push(row);
      }
      const currentWorld = worldData[lastWorldType];
      const currentGame = { player: currentWorld.player, target: currentWorld.target };
      let targetPlaced = false;
      for (let i = 0; i < height && !targetPlaced; i++) {
        for (let j = 0; j < width && !targetPlaced; j++) {
          if (gameGrid[i][j] === " ") {
            gameGrid[i][j] = currentGame.target;
            targetPlaced = true;
          }
        }
      }
      if (!gameGrid.flat().includes(currentGame.player)) {
        let freeCells = [];
        for (let i = 0; i < height; i++) {
          for (let j = 0; j < width; j++) {
            if (gameGrid[i][j] === " ") freeCells.push({ x: j, y: i });
          }
        }
        if (freeCells.length > 0) {
          const pos = freeCells[Math.floor(Math.random() * freeCells.length)];
          gameGrid[pos.y][pos.x] = currentGame.player;
          playerX = pos.x;
          playerY = pos.y;
        }
      }
      initialTargetCount = gameGrid.flat().filter(cell => cell === currentGame.target).length;
      renderGameGrid();
    }
    
    function movePlayer(dx, dy) {
      if (!timerStart) {
        timerStart = Date.now();
        timerInterval = setInterval(updateTimer, 1000);
      }
      const currentWorld = worldData[lastWorldType];
      const currentGame = { player: currentWorld.player, target: currentWorld.target };
      const newX = playerX + dx;
      const newY = playerY + dy;
      if (newX < 0 || newX >= width || newY < 0 || newY >= height) {
        playPowSound();
        return;
      }
      const cellContent = gameGrid[newY][newX];
      if (cellContent === " " || cellContent === currentGame.target) {
        if (cellContent === currentGame.target) {
          playPewSound();
          foundCount++;
          document.getElementById("foundCount").innerText = "Gefundene Ziele: " + foundCount;
          if (foundCount >= initialTargetCount) {
            clearInterval(timerInterval);
            timerInterval = null;
            setTimeout(() => {
              playTuschSound();
              const seconds = Math.floor((Date.now() - timerStart) / 1000);
              alert("Spiel beendet! Gefundene Ziele: " + foundCount + ", Zeit: " + seconds + " s");
            }, 600);
          }
        }
        gameGrid[playerY][playerX] = " ";
        gameGrid[newY][newX] = currentGame.player;
        playerX = newX;
        playerY = newY;
        renderGameGrid();
      } else {
        playPowSound();
      }
    }
    
    document.addEventListener("keydown", function(e) {
      let dx = 0, dy = 0;
      switch(e.key) {
        case "ArrowUp":    dy = -1; break;
        case "ArrowDown":  dy = 1;  break;
        case "ArrowLeft":  dx = -1; break;
        case "ArrowRight": dx = 1;  break;
        default: return;
      }
      movePlayer(dx, dy);
    });
    
    function copyToClipboard() {
      if (!navigator.clipboard || !navigator.clipboard.write) {
        alert("Das Kopieren von Bitmaps wird auf diesem Gerät nicht unterstützt.");
        return;
      }
      html2canvas(document.getElementById("gridOutput")).then(canvas => {
        canvas.toBlob(blob => {
          const item = new ClipboardItem({ "image/png": blob });
          navigator.clipboard.write([item]).then(() => {
            alert("Bitmap kopiert!");
          }).catch(err => {
            console.error("Fehler beim Kopieren: ", err);
            alert("Fehler beim Kopieren der Bitmap.");
          });
        });
      });
    }
    
function generateAltText() {
  // Hole die aktuell ausgewählte Welt aus worldData
  const currentWorldKey = document.getElementById("worldSelect").value;
  const currentWorld = worldData[currentWorldKey];
  
  // Verwende die Beschreibung, sofern vorhanden – ansonsten falls nicht definiert, den worlds key
  const description = currentWorld.description || currentWorldKey;
  
  // Erzeuge den ALT-Text, der nun die in worldData definierte Description beinhaltet
  let altText = "Alternativtext: Dieses Bild zeigt eine " + description + " Welt, erstellt mit dem Weltensymbol Editor. ";
  altText += "Das Raster hat " + gridRows + " Zeilen und " + gridCols + " Spalten.";
  
  navigator.clipboard.writeText(altText)
    .then(() => alert("ALT Text kopiert!"))
    .catch(err => alert("Fehler beim Kopieren des ALT Texts: " + err));
}

    
    function transferToEditor() {
      const params = new URLSearchParams();
      params.set("world", lastWorldType);
      const gridText = gameGrid.map(row => row.join("")).join("\n");
      params.set("grid", gridText);
      window.location.href = "welten_editor.html?" + params.toString();
    }
    
    window.addEventListener("load", () => {
      generateDefaultGrid();
      loadGameFromParams();
    });
    
    document.addEventListener("keydown", function(e) {
      switch(e.key) {
        case "ArrowUp":
          movePlayer(0, -1);
          break;
        case "ArrowDown":
          movePlayer(0, 1);
          break;
        case "ArrowLeft":
          movePlayer(-1, 0);
          break;
        case "ArrowRight":
          movePlayer(1, 0);
          break;
      }
    });
  </script>
</body>
</html>
